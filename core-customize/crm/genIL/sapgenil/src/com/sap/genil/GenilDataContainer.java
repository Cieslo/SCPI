/*
 *
 *  [y] hybris Platform
 *
 *  Copyright (c) 2018 SAP SE or an SAP affiliate company. All rights reserved.
 *
 *  This software is the confidential and proprietary information of SAP
 *  ("Confidential Information"). You shall not disclose such Confidential
 *  Information and shall use it only in accordance with the terms of the
 *  license agreement you entered into with SAP.
 * /
 */

package com.sap.genil;

import de.hybris.platform.sap.core.bol.logging.Log4JWrapper;
import de.hybris.platform.sap.core.jco.exceptions.BackendException;
import de.hybris.platform.sap.core.jco.exceptions.BackendRuntimeException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.sap.genil.exception.GenilBackendException;
import com.sap.genil.exception.GenilBackendRuntimeException;
import com.sap.genil.rfc.GenilObjInstance;


/**
 * This Class is a container for CRM GenIL Objects. It is internally organized in the same way as GenIL.<br>
 * It provides methods to access the data in a similar way to CRM BOL. So you have a Tree-Like structure. The root,
 * which is in GenIL a root object, is represented by a root container. By calling the getChild methods with
 * corresponding relation name as argument you can navigate down the container structure until you reach the desired
 * leave access <br>
 *
 * @author SAP
 * @version 1.0
 *
 * @author C5230248 -- Modified by Removing WCFLocation and added Hybris Backend Exception -- Modified by removing
 *         parameter createNew from method GenilDataContainer as its unused
 */
public class GenilDataContainer
{

	/**
	 * Logging instance
	 */
	protected static final Log4JWrapper logger = Log4JWrapper.getInstance(GenilDataContainer.class.getName());

	/**
	 * A corresponding object to this container already exists on the GenIL-Layer, and the container was modified since
	 * the last read.
	 */
	public static final char DELTA_MODIFIED = 'M';
	/**
	 * A corresponding object in the GenIL layer does not exist, the container was newly created.
	 */
	public static final char DELTA_CREATED = 'N';
	/**
	 * A corresponding object in the GenIL Layer exists, but this container was marked for deletion.
	 */
	public static final char DELTA_DELETED = 'D';
	/**
	 * Container has not been touched so far
	 */
	public static final char DELTA_UNCHANGED = ' ';
	/**
	 * Indicates if this container is invalid, which means that a re-read is required
	 */
	private boolean invalid;
	/**
	 * Indicates the kind of delta
	 */
	private char deltaFlag;
	/**
	 * This Map stores all attributes that belong to this object. Key is the attribute name and value is the actual value
	 * of the attribute.
	 */
	private Map<String, GenilAttribute> attributes;
	/**
	 * This map stores all relation that belong to this objects. Key is the rtGuid tracks if an attribute was updated.
	 * Key attribute name, value Boolean, indicating if the attribute was updated or not
	 */
	private Map<String, Map<String, GenilDataContainer>> relationsByRTGuid;
	private Map<String, List<GenilDataContainer>> relationsByName;

	protected Map<String, Map<String, GenilDataContainer>> getRelations()
	{
		return relationsByRTGuid;
	}

	protected void setRelations(final Map<String, Map<String, GenilDataContainer>> relations)
	{
		this.relationsByRTGuid = relations;
	}

	protected Map<String, Map<String, GenilDataContainer>> getRelationsByRTGuid()
	{
		return relationsByRTGuid;
	}

	protected void setRelationsByRTGuid(final Map<String, Map<String, GenilDataContainer>> relationsByRTGuid)
	{
		this.relationsByRTGuid.putAll(relationsByRTGuid);
	}

	protected Map<String, List<GenilDataContainer>> getRelationsByName()
	{
		return relationsByName;
	}

	protected void setRelationsByName(final Map<String, List<GenilDataContainer>> relationsByName)
	{
		this.relationsByName.putAll(relationsByName);
	}

	/**
	 * Indicates if this Container is a root Container.
	 */
	private boolean isRoot = false;
	/**
	 * Runtime GUID of this container, generated by the GENIL-RFC function modules
	 */
	private String rtGuid;
	/**
	 * Reference to the parent Container.
	 */
	private GenilDataContainer parent;
	/**
	 * Name of the GenIL relation from the parent to this container
	 */
	private String relationFromParent;
	/**
	 * GeniL name of the object represented by this container
	 */
	private String objectName;
	/**
	 * List to Store all child containers that have been created, modified, flagged for deletion since the last reset
	 */

	private Set<GenilDataContainer> changedConainers;

	/**
	 * Standard constructor. <br>
	 *
	 * @param parent
	 *           Reference to the parent Container
	 * @param relationName
	 *           Name of the GenIL relation from the parent to this entity.
	 */
	protected GenilDataContainer(final GenilDataContainer parent, final String relationName)
	{

		init(parent, relationName, null, 16, 16);
		// no runtime GUID, so this is a new Object
		this.changeDelta(DELTA_CREATED);
	}

	/**
	 * Standard constructor. <br>
	 *
	 * @param parent
	 *           Reference to the parent Container
	 * @param relationName
	 *           Name of the GenIL relation from the parent to this entity.
	 * @param rtGuig
	 *           runtime GUID of genIL RFC Interface
	 */
	protected GenilDataContainer(final GenilDataContainer parent, final String relationName, final String rtGuid)
	{

		init(parent, relationName, rtGuid, 16, 16);
	}

	/**
	 * If one knows the expected numbers of attributes and relations in advance, one can use this constructor to optimize
	 * performance.<br>
	 * If you do not set this numbers, or if they are incorrect, some rehashing might occur.
	 *
	 * @param parent
	 *           Reference to the parent Container
	 * @param relationName
	 *           Name of the GenIL relation from the parent to this entity.
	 * @param numberOfAttr
	 *           Expected number of Attributes
	 * @param numberOfRelTyps
	 *           Expected number of relation types
	 */
	protected GenilDataContainer(final GenilDataContainer parent, final String relationName, final String rtGuid,
			final int numberOfAttr, final int numberOfRelsTyps)
	{
		// In some cases we know the number of attributes or child relations in
		// advance. Then it makes sense to init the corresponding lists with a
		// proper initial capacity. We use the default load factor of 0.75, so
		// that means we have to initialize the map with
		// capacity = ('expected size' / 0.75) + 1 to avoid rehashing
		Double tmp;
		tmp = numberOfAttr / 0.75;
		final int attrSize = tmp.intValue() + 1;
		tmp = numberOfRelsTyps / 0.75;
		final int relSize = tmp.intValue() + 1;
		init(parent, relationName, rtGuid, attrSize, relSize);
	}

	/**
	 * Adds an GeniLAttribute to the container, without affecting the delta flag.<br>
	 * Should be used to build the container after read.<br>
	 *
	 * @param attr
	 *           GenilAttribute to add
	 */
	protected void addAttribute(final GenilAttribute attr)
	{
		// no model check (we assume any data coming from GenIL fits to the
		// model)
		final String name = attr.getName();
		attributes.put(name, attr);
	}

	protected void addAttribute(final String name, final String value)
	{
		final GenilAttribute attr = new GenilAttribute(name, value);
		addAttribute(attr);
	}

	/**
	 * Creates a new GenIL Attribute an adds it to this container, without affecting the delta flag.<br>
	 * Should be used to build the container after read.<br>
	 *
	 * @param name
	 *           Attribute Name
	 * @param value
	 *           Attribute value
	 * @param property
	 *           GenIL property of the Attribute
	 * @throws GenilBackendException
	 *            if the attribute is invalid
	 */
	protected void addAttribute(final String name, final String value, final char property)
	{
		final GenilAttribute attr = new GenilAttribute(name, value, property);
		addAttribute(attr);
	}

	/**
	 * Adds the given container the list of changed containers <br>
	 *
	 * @param cont
	 *           Container to add
	 */
	protected void addChangedContainer(final GenilDataContainer cont)
	{
		changedConainers.add(cont);

		if (parent != null)
		{
			parent.addChangedContainer(this);
		}
	}

	protected void addChild(final String relationName, final GenilDataContainer cont)
	{
		// ensure that a list, to which the container can be added,
		// for this relation kind exists
		final List<GenilDataContainer> list = prepareChildList(relationName, false);
		final Map<String, GenilDataContainer> map = prepareChildList(relationName, cont.getRtGuid(), false);

		// add container
		list.add(cont);
		map.put(relationName + cont.getRtGuid(), cont);
	}

	/**
	 * This Method will instantiate an empty container and set it as child to this container using the given relation
	 * name and runtime GUID, without affecting the delta flag.<br>
	 * Should be used to build the container after read.<br>
	 * The empty container is the returned for further processing.<br>
	 *
	 * @param relationName
	 *           Name of the GenIL relation from the parent to this entity, not allowed to be empty.
	 * @param rtGuig
	 *           runtime GUID of genIL RFC Interface
	 * @return An Empty GenilDataContainer, that can be used for further processing
	 * @throws GenilBackendException
	 */
	protected GenilDataContainer addChild(final String relationName, final String rtGuid)
	{
		return addChild(relationName, rtGuid, 16, 16);
	}

	/**
	 * This Method will instantiate an empty container and set it as child to this container using the given relation
	 * name and runtime GUID, without affecting the delta flag.<br>
	 * Should be used to build the container after read.<br>
	 * The empty container is the returned for further processing. <br>
	 *
	 * @param relationName
	 *           Name of the GenIL relation from the parent to this entity, not allowed to be empty.
	 * @param rtGuig
	 *           runtime GUID of genIL RFC Interface
	 * @param numberOfAttr
	 *           Expected number of Attributes
	 * @param numberOfRelTyps
	 *           Expected number of relation types Name of the GenIL relation from the parent to this entity.
	 * @return An Empty GenilDataContainer, that can be used for further processing.
	 * @throws GenilBackendException
	 */
	protected GenilDataContainer addChild(final String relationName, final String rtGuid, final int numberAttr,
			final int numberRelTypes)
	{

		// check if object exists in global object hash
		final String key = getObjectNameByRelation(relationName) + rtGuid;
		GenilDataContainer container = getRoot().getAllObjectsByRTGuid().get(key);

		// ensure that a list, to which the container can be added,
		// for this relation kind exists
		final List<GenilDataContainer> list = prepareChildList(relationName, false);
		final Map<String, GenilDataContainer> map = prepareChildList(relationName, rtGuid, false);

		// if i am a new container, my child is also a new one
		if (deltaFlag == GenilDataContainer.DELTA_CREATED)
		{
			// create a new container without GUID reference to ensure that the
			// container is marked as DELTA_CREATED
			container = new GenilDataContainer(this, relationName);
			container.setRtGuid(rtGuid);

		}
		else
		{
			// create a new container, that has a reference to this container
			// Object does not exist, so create it
			if (container == null)
			{
				container = new GenilDataContainer(this, relationName, rtGuid, numberAttr, numberRelTypes);
				getRoot().getAllObjectsByRTGuid().put(key, container);
			}

		}

		// check if the container is not already in from former access (e.g.
		// during reread)
		// if not, add container
		if (!list.contains(container))
		{
			list.add(container);
		}
		map.put(relationName + rtGuid, container);
		return container;
	}

	/**
	 * Based on the current delta flag the requested delta flag is set.<br>
	 * For example deleting a new container results in no changes, the new container is just discarded.
	 *
	 * @param newDeltaFlag
	 *           New DeltaFlag to set
	 */
	private void changeDelta(final char newDeltaFlag)
	{

		// old flag
		final char oldDeltaFlag = this.deltaFlag;

		if (oldDeltaFlag == DELTA_CREATED)
		{
			checkNewDeltaCreated(newDeltaFlag);
		}
		else if (oldDeltaFlag == DELTA_MODIFIED)
		{
			checkOldDeltaModified(newDeltaFlag);
		}
		else if (oldDeltaFlag == DELTA_UNCHANGED)
		{
			checkOldDeltaUnchanged(newDeltaFlag);
		}
		else if (oldDeltaFlag == DELTA_DELETED && newDeltaFlag == DELTA_UNCHANGED)
		{
		
				// reset
				this.deltaFlag = DELTA_UNCHANGED;
				if (parent != null)
				{
					parent.removeChangedContainer(this);
				}
		
		}

	}

	/**
	 * @param newDeltaFlag
	 */
	private void checkOldDeltaUnchanged(final char newDeltaFlag)
	{
		if (newDeltaFlag == DELTA_UNCHANGED)
		{
			logger.getLogger();
		}
		else
		{
			// delta unchanged ==> apply any new flag
			this.deltaFlag = newDeltaFlag;
			if (parent != null)
			{
				parent.addChangedContainer(this);
			}
		}
	}

	/**
	 * @param newDeltaFlag
	 */
	private void checkOldDeltaModified(final char newDeltaFlag)
	{
		if (newDeltaFlag == DELTA_DELETED)
		{
			// if we delete, than forget about the changes
			this.deltaFlag = DELTA_DELETED;
		}
		else if (newDeltaFlag == DELTA_UNCHANGED)
		{
			// reset
			this.deltaFlag = DELTA_UNCHANGED;
			if (parent != null)
			{
				parent.removeChangedContainer(this);
			}
		}
	}

	/**
	 * @param newDeltaFlag
	 */
	private void checkNewDeltaCreated(final char newDeltaFlag)
	{
		if (newDeltaFlag == DELTA_DELETED)
		{
			// delete new cont, is like remove it from parent
			this.deltaFlag = DELTA_UNCHANGED;
			if (parent != null)
			{
				parent.removeChangedContainer(this);
				parent.removeChild(this);
			}
		}
		else if (newDeltaFlag == DELTA_UNCHANGED)
		{
			// delete new cont, is like reset
			this.deltaFlag = DELTA_UNCHANGED;
			if (parent != null)
			{
				parent.removeChangedContainer(this);
			}
		}
	}

	/**
	 * Utility method to clean up DataContainer hierarchy, if a container is removed
	 */
	private void cleanUp()
	{
		// we really need this
		for (final GenilDataContainer cont : getAllChilds())
		{
			cont.cleanUp();
		}
		// remove container from changed container list, if it is listed there
		if (parent != null)
		{
			parent.removeChangedContainer(this);
		}
	}

	/**
	 * This Method will instantiate an empty container and set it as child to this container using the given relation
	 * name, which is not allowed to be empty. The container is flagged with delta flag create. <br>
	 * Use this method if you want to create new dependent data in the GenIL layer. To create a new RootObject,
	 * instantiate a new Root Container and call the createRoot method of the proxy.<br>
	 * The empty container is the returned for further processing. <br>
	 * Throws a <code>GenilBackendRuntimeException</code> if container is not changeable.
	 *
	 * @param relationName
	 *           of the GenIL relation from the parent to this entity, not allowed to be empty.
	 * @return An Empty GenilDataContainer, that can be used for further processing. *
	 * @throws GenilBackendException
	 */
	public GenilDataContainer createChild(final String relationName)
	{
		if (!isChangeable())
		{
			final String msg = "Container " + this.toString() + " is not changeable ";
			final GenilBackendRuntimeException gnlBkndExc = new GenilBackendRuntimeException(msg);
			throw gnlBkndExc;
		}

		// create a new container, that has a reference to this container
		final GenilDataContainer cont = new GenilDataContainer(this, relationName);

		// check if relation is valid & ensure that a list, to which the
		// container can be added, for this relation kind exists
		final List<GenilDataContainer> list = prepareChildList(relationName, true);
		final Map<String, GenilDataContainer> map = prepareChildList(relationName, cont.getRtGuid(), true);

		// Set interims handle
		// cont.setRtGuid(UUID.randomUUID().toString().replace("-", "")


		// add container
		list.add(cont);
		map.put(relationName + cont.getRtGuid(), cont);
		return cont;
	}

	/**
	 * This method will mark this container as to be deleted. Throws a <code>GenilBackendRuntimeException</code> if
	 * container is not locked.
	 */
	public void delete()
	{
		final String method = "delete()";
		logger.getInstance(method);

		if (!isChangeable())
		{
			final String msg = "Container " + this.toString() + " is not changeable ";
			final BackendRuntimeException gnlBkndExc = new BackendRuntimeException(msg);
			throw gnlBkndExc;
		}
		changeDelta(DELTA_DELETED);

		// set for all child recursively the DELTA_DELETED flag
		// What if relation points to another root?
		final List<GenilDataContainer> childs = this.getAllChilds();
		final Iterator<GenilDataContainer> itr = childs.iterator();
		while (itr.hasNext())
		{
			final GenilDataContainer child = itr.next();
			child.changeDelta(DELTA_DELETED);
			setDeleteFlag(child);
		}
	}

	/**
	 * This method will mark all child container as deleted.
	 *
	 * @param parent
	 *           Container to remove
	 */
	private void setDeleteFlag(final GenilDataContainer parent)
	{
		final List<GenilDataContainer> childs = parent.getAllChilds();
		final Iterator<GenilDataContainer> itr = childs.iterator();
		while (itr.hasNext())
		{
			final GenilDataContainer child = itr.next();
			child.changeDelta(DELTA_DELETED);
			setDeleteFlag(child);
		}
	}

	/**
	 * This method is a shortcut to get all attributes. The list is immutable.<br>
	 * Please make sure that you have read this GenIL object with the flag <code>attrRequested</code>, otherwise the
	 * attribute list will be empty.<br>
	 *
	 * @return An unmodifiable List of all attributes of this container, or an empty list if there are no children.
	 */
	public Collection<GenilAttribute> getAllAttribues()
	{
		// special case: if there are no attributes at all, just return the
		// shared empty List Object.
		if (attributes.isEmpty())
		{
			return Collections.emptyList();
		}
		// changes to attributes have to be done via the fitting container
		// methods, to ensure that they get tracked, so only return a read-only
		// list.
		return Collections.unmodifiableCollection(attributes.values());

	}

	/**
	 * This method is a shortcut to get all child containers. The list is immutable.<br>
	 *
	 * @return An unmodifiable List of all child container over all relations, or an empty list if there are no children.
	 */
	public List<GenilDataContainer> getAllChilds()
	{
		// special case: if there are no relations at all, just return the
		// shared empty List Object.
		if (relationsByName.isEmpty())
		{
			return Collections.emptyList();
		}
		final List<GenilDataContainer> allChilds = new ArrayList<GenilDataContainer>();
		// Add all children of each relation kind to the list of all children.
		for (final List<GenilDataContainer> childs : relationsByName.values())
		{
			allChilds.addAll(childs);
		}

		// changes to child have to be done via the fitting container methods,
		// to ensure that they get tracked, so only return a read-only list.
		return Collections.unmodifiableList(allChilds);
	}

	/**
	 * Returns an unmodifiable list of all GenilAttributes that have been updated, since the last reset.
	 *
	 * @return A unmodifiable List of all updates attributes, or an empty list if there are no changes.
	 */
	public List<GenilAttribute> getAllUpdatedAttributes()
	{
		// special case: if there are no attributes at all or no changes, just
		// return the shared empty List Object.
		if (getAllAttribues().isEmpty() || deltaFlag == DELTA_UNCHANGED)
		{
			return Collections.emptyList();
		}
		final List<GenilAttribute> attrList = new ArrayList<GenilAttribute>();
		for (final GenilAttribute attr : getAllAttribues())
		{
			if (deltaFlag == DELTA_CREATED || attr.isUpdated())
			{
				attrList.add(attr);
			}
		}
		// changes to attributes have to be done via the fitting container
		// methods, to ensure that they get tracked, so only return a read-only
		// list.
		return Collections.unmodifiableList(attrList);
	}

	/**
	 * This Method can be used to get a whole <code>GenilAttribute</code>. This is use full if plan to read also meta
	 * data associated with this attribute, for example the GenIL property. If you just require the value, you can also
	 * call the <code>getAttributeValue(String name)</code> method.
	 *
	 * @see com.sap.wec.tc.core.backend.genil.GenilDataContainer#getAttributeValue(String)
	 * @param name
	 *           Name of the attribute to read
	 * @return A GenilAttribute with the given name, or null if the attribute does not exist.
	 */
	public GenilAttribute getAttribute(final String name)
	{
		return attributes.get(name);
	}

	/**
	 * This method is a shortcut to direct access the attribute value by providing the attribute name.<br>
	 * If the attribute does not exist this method will return an empty string rather than <code>null</code>. To check if
	 * an attribute exists call <code>getAttributes(String name)</code> and check for <code>null</code>.
	 *
	 * @see com.sap.wec.tc.core.backend.genil.GenilDataContainer#getAttribute(String)
	 * @param name
	 *           Name of the attribute to read
	 * @return value of the attribute as string, or an empty String if the attribute does not exist
	 */
	public String getAttributeValue(final String name)
	{
		final GenilAttribute attr = attributes.get(name);
		if (attr == null)
		{
			return "";
		}
		return attr.getValue();
	}

	/**
	 * This method will return a unmodifiable list of child containers that have been modified, created or marked for
	 * deletion since the last reset of the delta state. Call <code>getDeltaState()</code> method on each container to
	 * get the info what has changed.<br>
	 *
	 * @return A list of child containers that have been modified or created or deleted
	 */
	public Set<GenilDataContainer> getChangedContainers()
	{
		return Collections.unmodifiableSet(changedConainers);
	}

	public Map<String, Set<GenilDataContainer>> getChangedContainersPerRelation()
	{
		final Map<String, Set<GenilDataContainer>> result = new HashMap<String, Set<GenilDataContainer>>();
		for (final GenilDataContainer cont : changedConainers)
		{
			Set<GenilDataContainer> rel = result.get(cont.getRelationFromParent());
			if (rel == null)
			{
				rel = new HashSet<GenilDataContainer>();
				result.put(cont.getRelationFromParent(), rel);
			}
			rel.add(cont);
		}
		return result;
	}



	/**
	 * @param relationName
	 *           child relationName to search for
	 * @param rtGuid
	 *           child GUID to search for
	 *
	 * @return Child we searched for or null if there isn't a child with this GUID
	 *
	 */
	public GenilDataContainer getChildByRtGuid(final String relationName, final String rtGuid)
	{

		final Map<String, GenilDataContainer> childs = getRoot().getRelationsByRTGuid().get(relationName + rtGuid);

		if (childs != null)
		{
			for (final Map.Entry<String, GenilDataContainer> entry : childs.entrySet())
			{
				return entry.getValue();
			}
		}

		return null;
	}

	/**
	 * This method provides an unmodifiable set of the all the relation names that lead to children of this container.
	 *
	 * @return An unmodifiable Set of all relation names that are child to this container
	 */
	public Set<String> getChildRelationNames()
	{
		// special case: if there are no relations at all, just return the
		// shared empty Set Object.
		if (relationsByName.isEmpty())
		{
			return Collections.emptySet();
		}
		// changes to children have to be done via the fitting container
		// methods,
		// to ensure that they get tracked, so only return a read-only Set
		return Collections.unmodifiableSet(relationsByName.keySet());
	}

	/**
	 * Returns a List of all Child dataContainer for this GenIL relation
	 *
	 * @param relationName
	 *           Name of the GenIL relation
	 * @return An unmodifiable List of all Child data containers, or an empty list if there are no children.
	 */
	public List<GenilDataContainer> getChilds(final String relationName)
	{
		final List<GenilDataContainer> childs = relationsByName.get(relationName);
		if (childs == null)
		{
			return Collections.emptyList();
		}
		return Collections.unmodifiableList(childs);
	}

	/**
	 * Getter-Method for property {@link #deltaFlag}. <br>
	 *
	 * @return Returns the {@link #deltaFlag}.
	 */
	public char getDeltaFlag()
	{
		return deltaFlag;
	}

	/**
	 * Returns a GenilDataContainer of which is the first Child dataContainer for this GenIL relation
	 *
	 * @param relationName
	 *           Name of the GenIL relation
	 * @return A GenilDataContainer of which is the first Child dataContainer for this GenIL relation, or null if there
	 *         are no childs.
	 */
	public GenilDataContainer getFirstChild(final String relationName)
	{
		final List<GenilDataContainer> childs = relationsByName.get(relationName);
		if (childs == null)
		{
			return null;
		}
		return childs.get(0);

	}

	protected GenilObjInstance getGenilObjInst()
	{
		return new GenilObjInstance(objectName, rtGuid);
	}

	/**
	 * Returns a GenilDataContainer of which is the last Child dataContainer for this GenIL relation
	 *
	 * @param relationName
	 *           Name of the GenIL relation
	 * @return A GenilDataContainer of which is the last Child dataContainer for this GenIL relation, or null if there
	 *         are no children.
	 */
	public GenilDataContainer getLastChild(final String relationName)
	{
		final List<GenilDataContainer> childs = relationsByName.get(relationName);
		if (childs == null)
		{
			return null;
		}
		final int i = childs.size() - 1;
		if (i < 0)
		{
			return null;
		}
		return childs.get(i);
	}

	/**
	 * Provides the msg. container which matches the rtGuid
	 */

	public GenilMessageContainer getMessageContainer()
	{
		final GenilMessageContainerManager msgContManager = this.getRoot().getProxy().getMsgContManager();
		GenilMessageContainer result = msgContManager.getObjectMessageContainer(this.rtGuid);
		if (result == null)
		{
			result = new GenilMessageContainer();
		}
		return result;
	}

	/**
	 * Provides the msg. container of the closest access/root data container
	 */

	public GenilMessageContainer getMessageContainerOfAccessOrRoot()
	{
		final GenilMessageContainerManager msgContManager = this.getRoot().getProxy().getMsgContManager();
		if (!(getModelObject().getObjectKind() == GenilModelObjectKind.ACCESS && getModelObject().getObjectKind() == GenilModelObjectKind.ROOT))
		{
			parent.getMessageContainerOfAccessOrRoot();
		}
		return msgContManager.getObjectMessageContainer(this.rtGuid);
	}

	/**
	 * Utility Method to obtain the GenIL Model Object this container is associated to. This object provides design time
	 * information from GenIL Model.<br>
	 *
	 * @return GenilModelObject this container is associated to
	 */
	public GenilModelObject getModelObject()
	{
		return this.getRoot().getProxy().getModel().getObject(objectName);
	}

	/**
	 * Return the property {@link #objectName}. <br>
	 *
	 * @return Returns the {@link #objectName}.
	 */
	public String getObjectName()
	{
		return objectName;
	}

	/**
	 * Return the property {@link #parent}. <br>
	 *
	 * @return Returns the {@link #parent}.
	 */
	public GenilDataContainer getParent()
	{
		return parent;
	}

	/**
	 * This methods returns the path from the root object as a StringBuffer, using the following syntax<br>
	 * <code>RootObjectName[RuntimeGUID]\\RealationName:ObjectName[RuntimeGUID]</code>
	 *
	 * @return The Path from the root object as StringBuffer
	 */
	public StringBuilder getPathAsString()
	{
		if (parent != null)
		{
			final StringBuilder path = parent.getPathAsString();
			path.append("\\");
			path.append(relationFromParent);
			path.append(":");
			path.append(objectName);
			path.append("[");
			path.append(rtGuid);
			path.append("]");
			return path;
		}
		return null;
	}

	/**
	 * Return the property {@link #relationFromParent}. <br>
	 *
	 * @return Returns the {@link #relationFromParent}.
	 */
	public String getRelationFromParent()
	{
		return relationFromParent;
	}

	/**
	 * This method will create a requestContainer structure that models a request to re-read exactly this child with
	 * exactly this GUID.<br>
	 * If you also want to re-read the attributes of this object, you have to set the flag attrRequested manually.<br>
	 *
	 * @return Request Container for re-read
	 * @throws GenilBackendException
	 *            if the container can not be constructed
	 * @throws BackendException
	 */
	public GenilReadKeyRequestContainer getRequestContainer() throws BackendException
	{
		if (rtGuid == null)
		{
			final String msg = "Container " + this.toString() + " is not changeable ";
			final GenilBackendRuntimeException gnlBkndExc = new GenilBackendRuntimeException(msg);
			throw gnlBkndExc;
		}
		GenilReadKeyRequestContainer req;
		req = parent.getRequestContainer();
		// add this entity to request.
		req = req.addChildRel(relationFromParent, rtGuid);
		return req;
	}

	/**
	 * Returns the RootdataContainer that is the root of this DataContainer
	 *
	 * @return Returns the RootdataContainer that is the root of this DataContainer
	 */
	public GenilRootDataContainer getRoot()
	{
		return parent.getRoot();
	}

	/**
	 * Getter-Method for property {@link #rtGuid}. <br>
	 *
	 * @return Returns the {@link #rtGuid}.
	 */
	public String getRtGuid()
	{
		return rtGuid;
	}

	/**
	 * Initializes this data container.<br>
	 *
	 * @param parent
	 *           Reference to the parent Container
	 * @param Name
	 *           of the GenIL relation from the parent to this entity.
	 * @param attrCapacity
	 *           initial capacity for the attribute maps
	 * @param relCapacity
	 *           initial capacity for the relmap
	 */
	private void init(final GenilDataContainer parent, final String relationName, final String rtGuid, final int attrCapacity,
			final int relCapacity)
	{

		// set class attributes
		this.parent = parent;
		this.rtGuid = rtGuid;
		this.relationFromParent = relationName;
		this.deltaFlag = DELTA_UNCHANGED;
		this.invalid = false;
		// init HashMaps
		this.attributes = new HashMap<String, GenilAttribute>(attrCapacity);

		// this.relations = new HashMap<String, List<GenilDataContainer>>(

		this.relationsByRTGuid = new HashMap<String, Map<String, GenilDataContainer>>(relCapacity);
		this.relationsByName = new HashMap<String, List<GenilDataContainer>>(relCapacity);

		// get Object name in case of root, parent is null, but then objectName
		// is set in constructor of GenilRootDataContainer
		if (parent != null)
		{
			objectName = parent.getModelObject().getRelation(relationName).getObjectB().getObjectName();
		}
		changedConainers = new HashSet<GenilDataContainer>();
	}

	protected void invalidate(final Map<String, GenilObjInstance> changedObjects)
	{
		for (final GenilDataContainer child : getAllChilds())
		{
			child.invalidate(changedObjects);
		}

		final GenilObjInstance objInst = changedObjects.remove(getRtGuid());
		if (objInst != null)
		{
			setInvalid(true);
		}
	}

	/**
	 * This method indicates if an attribute is changeable.<br>
	 * if you try to change an unchangeable attribute this leads to a runtime exception.
	 *
	 * @param name
	 *           of the attribute to test
	 * @return <code>true</code> only if either the container is changeable and if it is in create mode, or if the
	 *         container is changeable and if such an attribute exists and if it is changeable.
	 */
	public boolean isAttributeChangeable(final String name)
	{
		if (!isChangeable())
		{
			return false;
		}

		// OK container changeable, also the attribute?
		GenilAttribute attr = attributes.get(name);
		if (attr != null)
		{
			return attr.isChangeable();
		}
		// Attribute does not exists so far, if this container is in create
		// mode, it is OK to add an attribute, otherwise not.
		// ==> in case you want to update an attribute, you always have to read
		// it before
		if (deltaFlag == DELTA_CREATED)
		{
			return true;
		}
		else
		{

			// If we are not in create mode, it could be that the attribute is
			// not created because it was an changable empty value from backend.
			// Check if the attribute is allowed and create it. Changable empty
			// values are not created to save memory
			if (isAttributeInModel(name))
			{
				// Create Attribute
				attr = new GenilAttribute(name, "", GenilAttribute.CHANGEABLE);
				attributes.put(name, attr);
				return true;

			}
			else
			{
				return false;
			}
		}

	}

	/**
	 * Checks in the GenIL Model if there exits such an attribute for the GenIL object this container is associated to.<br>
	 *
	 * @param attributeName
	 *           Name of the Relation to check
	 * @return <code>true</code> only if the given attribute is valid
	 */
	public boolean isAttributeInModel(final String attributeName)
	{
		if (getModelObject().getAttrByName(attributeName) == null)
		{
			return false;
		}
		return true;
	}

	/**
	 * Checks if the container can be changed.<br>
	 * Result is define by the following condition.
	 * <code>!isInvalid() && (getDeltaFlag() == DELTA_CREATED || isLocked())</code>
	 *
	 * @return returns <code>true</code> only if the container is not invalid and if it is locked or if it is in create
	 *         mode.
	 */
	public boolean isChangeable()
	{
		if (!isInvalid() && (getDeltaFlag() == DELTA_CREATED || isLocked()))
		{
			return true;
		}
		return false;
	}

	/**
	 * Getter-Method for property {@link #invalid}. <br>
	 *
	 * @return Returns the {@link #invalid}.
	 */
	public boolean isInvalid()
	{
		return invalid;
	}

	/**
	 * Locks can only be applied to root Objects. <br>
	 * This method will call the root Object to find out if it is locked
	 *
	 * @return only returns <code>true</code> if the root object is locked
	 */
	public boolean isLocked()
	{
		return getRoot().isLocked();
	}

	/**
	 * Checks in the GenIL Model if there exits such an relation for the GenIL object this container is associated to.<br>
	 *
	 * @param relationName
	 *           Name of the Relation to check
	 * @return <code>true</code> only if the given relation is valid
	 */
	public boolean isRelationInModel(final String relationName)
	{
		if (getModelObject().getRelation(relationName) == null)
		{
			return false;
		}
		return true;
	}

	/**
	 * Return the property {@link #isRoot}. <br>
	 *
	 * @return Returns the {@link #isRoot}.
	 */
	public boolean isRoot()
	{
		return isRoot;
	}

	/**
	 * This method does 2 things.<br>
	 * 1. It checks if the given relation name is valid for the parent object. If not. An exception is thrown.<br>
	 * 2. Ensures that there exists List(for this relationName) to add the child
	 *
	 * @param relationName
	 *           The relationName to add *
	 * @param rtGuid
	 *           The rtGuid to add *
	 * @param checkModel
	 *           if true a ModelCheck is performed
	 * @return the list where the child should be added
	 * @throws GenilBackendException
	 *            If the given relation is not valid
	 */

	private Map<String, GenilDataContainer> prepareChildList(final String relationName, final String rtGuid,
			final boolean checkModel)
	{
		// add this container as child, create a new ArrayList if this is
		// the first container
		Map<String, GenilDataContainer> rels = relationsByRTGuid.get(relationName + rtGuid);
		if (rels == null)
		{
			// only check model if required
			if (checkModel && !isRelationInModel(relationName))
			{
				final String msg = "The Relation " + relationName + " is not in Model for " + objectName;
				final GenilBackendRuntimeException gnlBkndExc = new GenilBackendRuntimeException(msg);
				throw gnlBkndExc;
			}
			rels = new HashMap<String, GenilDataContainer>();
			relationsByRTGuid.put(relationName + rtGuid, rels);

		}

		this.relationsByRTGuid.put(relationName + rtGuid, rels);
		return rels;
	}

	/**
	 * This method does 2 things.<br>
	 * 1. It checks if the given relation name is valid for the parent object. If not. An exception is thrown.<br>
	 * 2. Ensures that there exists List(for this relationName) to add the child
	 *
	 * @param relationName
	 *           The relationName to add *
	 * @param checkModel
	 *           if true a ModelCheck is performed
	 * @return the list where the child should be added
	 * @throws GenilBackendException
	 *            If the given relation is not valid
	 */

	private List<GenilDataContainer> prepareChildList(final String relationName, final boolean checkModel)
	{
		// add this container as child, create a new ArrayList if this is
		// the first container
		List<GenilDataContainer> rels = relationsByName.get(relationName);
		if (rels == null)
		{
			// only check model if required
			if (checkModel && !isRelationInModel(relationName))
			{
				final String msg = "The Relation " + relationName + " is not in Model for " + objectName;
				final GenilBackendRuntimeException gnlBkndExc = new GenilBackendRuntimeException(msg);
				throw gnlBkndExc;
			}
			rels = new ArrayList<GenilDataContainer>();
			relationsByName.put(relationName, rels);

		}

		return rels;
	}

	/**
	 * Removes this container from the container hierarchy.<br>
	 */
	protected void remove()
	{
		parent.removeChild(this);
	}

	/**
	 * Removes the given container the list of changed containers <br>
	 *
	 * @param cont
	 *           Container to remove
	 */
	protected void removeChangedContainer(final GenilDataContainer cont)
	{
		changedConainers.remove(cont);
		if (deltaFlag != DELTA_UNCHANGED && changedConainers.isEmpty() && parent != null)
		{
			parent.removeChangedContainer(this);
		}
	}

	/**
	 * Removes the given container from the container hierarchy.<br>
	 * if the the given container is not a child of this container, nothing happens
	 *
	 * @param cont
	 *           child container to remove
	 */
	protected void removeChild(final GenilDataContainer cont)
	{
		if (relationsByRTGuid.containsKey(cont.getRelationFromParent() + cont.getRtGuid()))
		{
			relationsByRTGuid.get(cont.getRelationFromParent() + cont.getRtGuid()).remove(
					cont.getRelationFromParent() + cont.getRtGuid());
			relationsByRTGuid.remove(cont.getRelationFromParent() + cont.getRtGuid());
			if (relationsByName.containsKey(cont.getRelationFromParent()))
			{
				relationsByName.get(cont.getRelationFromParent()).remove(cont);
				relationsByName.remove(cont.getRelationFromParent());
			}
			cont.cleanUp();
		}

	}

	/**
	 * Resets all Information about the delta state of this map.<br>
	 * Changes are NOT undone, just the information what changed is deleted.<br>
	 */
	protected void resetDeltaState()
	{
		changeDelta(DELTA_UNCHANGED);
		for (final GenilAttribute attr : attributes.values())
		{
			attr.setUpdated(false);
		}
		changedConainers.clear();

		for (final GenilDataContainer cont : getAllChilds())
		{
			cont.resetDeltaState();
		}
	}

	/**
	 * Sets the value for the given attribute object.<br>
	 * If the container is in create mode, the attribute will be created if it does not exit, yet. Throws a
	 * <code>GenilBackendRuntimeException</code> if <code>isAttributeChangebale()</code> returns <code>false</code>. Or
	 * in other words: Throws an exception if container is not locked, or the attribute is not changeable, or if the
	 * attribute does not exist and the container is not in create mode.
	 *
	 * @param name
	 *           GenIL name of the Attribute
	 * @param value
	 *           String value of the attribute
	 * @throws GenilBackendException
	 *            if the Attribute is invalid
	 */
	public void setAttributeValue(final String name, final String value)
	{
		if (!isAttributeChangeable(name))
		{
			final String msg = "The Attribute " + name + " is not changeable";
			final GenilBackendRuntimeException gnlBkndExc = new GenilBackendRuntimeException(msg);
			throw gnlBkndExc;
		}

		if (!isLocked())
		{
			final String msg = "The Container " + this.toString() + " is not locked";
			final GenilBackendRuntimeException gnlBkndExc = new GenilBackendRuntimeException(msg);
			throw gnlBkndExc;
		}

		GenilAttribute attr = attributes.get(name);
		if (attr == null)
		{
			// attr does not exists so far, so check in model if such an
			// attribute exists
			if (isAttributeInModel(name))
			{
				attr = new GenilAttribute(name, value);
				attributes.put(name, attr);
			}
			else
			{
				final String msg = "The attribute " + name + " is unknown in Model for " + objectName;
				final GenilBackendRuntimeException gnlBkndExc = new GenilBackendRuntimeException(msg);
				throw gnlBkndExc;
			}

		}
		else
		{
			attr.setValue(value);
			// check if this is an update
			if (attr.isUpdated())
			{
				changeDelta(DELTA_MODIFIED);
			}
		}
	}

	/**
	 * Setter-Method for property {@link #invalid}. <br>
	 *
	 * @param invalid
	 *           The {@link #invalid} to set.
	 */
	public void setInvalid(final boolean invalid)
	{
		this.invalid = invalid;
	}

	/**
	 * Set the property {@link #isRoot}. <br>
	 *
	 * @param isRoot
	 *           The {@link #isRoot} to set.
	 */
	protected void setIsRoot(final boolean isRoot)
	{
		this.isRoot = isRoot;
	}

	/**
	 * Adds the msg. container to the msg. container manager
	 */

	public void setMessageContainer(final GenilMessageContainer msgContainer)
	{
		final GenilMessageContainerManager msgContManager = this.getRoot().getProxy().getMsgContManager();
		msgContManager.setObjectMessageContainer(this.rtGuid, msgContainer);
	}

	/**
	 * Set the property {@link #objectName}. <br>
	 *
	 * @param objectName
	 *           The {@link #objectName} to set.
	 */
	protected void setObjectName(final String objectName)
	{
		this.objectName = objectName;
	}

	protected void setParent(final GenilDataContainer parent)
	{
		this.parent = parent;
	}

	protected void setRelationName(final String relationName)
	{
		this.relationFromParent = relationName;
	}

	/**
	 * Set the property {@link #rtGuid}. <br>
	 *
	 * @param rtGuid
	 *           The {@link #rtGuid} to set.
	 */
	protected void setRtGuid(final String rtGuid)
	{
		this.rtGuid = rtGuid;
	}

	/**
	 * Overwrites the super implementation.<br>
	 * Returns a User-friendly String representation of this container<br>
	 *
	 * @return User-Friendly textual representation of this object
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString()
	{
		final StringBuilder string = new StringBuilder();
		string.append(objectName);
		string.append(" with GUID: ");
		string.append(rtGuid);
		string.append(" | Path from root: \n");
		string.append(getPathAsString());
		return string.toString();

	}

	protected String getObjectNameByRelation(final String relation)
	{
		return getModelObject().getRelation(relation).getObjectB().getObjectName();
	}

}
